{
  "language": "Solidity",
  "sources": {
    "contracts/RandomPacket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface VRFCoordinatorV2Interface {\n    function requestRandomWords(\n        bytes32 keyHash,\n        uint64 subId,\n        uint16 minimumRequestConfirmations,\n        uint32 callbackGasLimit,\n        uint32 numWords\n    ) external returns (uint256 requestId);\n}\n\ninterface VRFConsumerBaseV2Interface {\n    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external;\n}\n\n/**\n * @title RandomPacket\n * @dev A smart contract for creating random packets with various reward types\n * Supports multiple randomness sources and packet types\n */\ncontract RandomPacket {\n    \n    // Events\n    event PacketCreated(uint256 indexed packetId, address indexed creator, uint256 totalValue);\n    event PacketOpened(uint256 indexed packetId, address indexed opener, uint256 reward, RewardType rewardType);\n    event RandomnessRequested(uint256 indexed requestId, uint256 indexed packetId);\n    event RandomnessFulfilled(uint256 indexed requestId, uint256 randomValue);\n    \n    // Enums\n    enum PacketStatus { Active, Opened, Expired, Cancelled }\n    enum RewardType { ETH, Token, NFT, Empty }\n    enum RandomnessSource { BlockHash, VRF, CommitReveal }\n    \n    // Structs\n    struct Packet {\n        address creator;\n        uint256 totalValue;\n        uint256 createdAt;\n        uint256 expiresAt;\n        PacketStatus status;\n        RewardType[] rewardTypes;\n        uint256[] rewardAmounts;\n        address[] tokenAddresses;\n        uint256[] nftIds;\n        RandomnessSource randomnessSource;\n        bool requiresVRF;\n        uint256 vrfRequestId;\n    }\n    \n    struct CommitRevealData {\n        bytes32 commitment;\n        uint256 revealDeadline;\n        bool revealed;\n        uint256 nonce;\n    }\n    \n    // State variables\n    mapping(uint256 => Packet) public packets;\n    mapping(uint256 => CommitRevealData) public commitRevealData;\n    mapping(uint256 => uint256) public vrfRequestToPacket;\n    mapping(address => uint256[]) public userPackets;\n    \n    uint256 public nextPacketId = 1;\n    uint256 public defaultExpiryTime = 7 days;\n    uint256 public commitRevealWindow = 1 hours;\n    \n    // VRF variables (Chainlink VRF V2)\n    VRFCoordinatorV2Interface public vrfCoordinator;\n    bytes32 public keyHash;\n    uint64 public subscriptionId;\n    uint16 public requestConfirmations = 3;\n    uint32 public callbackGasLimit = 100000;\n    \n    // Access control\n    address public owner;\n    mapping(address => bool) public authorizedCreators;\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n    \n    modifier onlyAuthorized() {\n        require(authorizedCreators[msg.sender] || msg.sender == owner, \"Not authorized\");\n        _;\n    }\n    \n    constructor(\n        address _vrfCoordinator,\n        bytes32 _keyHash,\n        uint64 _subscriptionId\n    ) {\n        owner = msg.sender;\n        authorizedCreators[msg.sender] = true;\n        vrfCoordinator = VRFCoordinatorV2Interface(_vrfCoordinator);\n        keyHash = _keyHash;\n        subscriptionId = _subscriptionId;\n    }\n    \n    /**\n     * @dev Create a simple ETH packet with block hash randomness\n     */\n    function createETHPacket(\n        uint256 _numRewards,\n        uint256[] memory _rewardAmounts\n    ) external payable returns (uint256) {\n        require(_numRewards > 0 && _numRewards <= 10, \"Invalid reward count\");\n        require(_rewardAmounts.length == _numRewards, \"Mismatched arrays\");\n        \n        uint256 totalValue = 0;\n        for (uint i = 0; i < _rewardAmounts.length; i++) {\n            totalValue += _rewardAmounts[i];\n        }\n        require(msg.value >= totalValue, \"Insufficient ETH sent\");\n        \n        RewardType[] memory rewardTypes = new RewardType[](_numRewards);\n        for (uint i = 0; i < _numRewards; i++) {\n            rewardTypes[i] = RewardType.ETH;\n        }\n        \n        uint256 packetId = _createPacket(\n            totalValue,\n            rewardTypes,\n            _rewardAmounts,\n            new address[](_numRewards),\n            new uint256[](_numRewards),\n            RandomnessSource.BlockHash\n        );\n        \n        return packetId;\n    }\n    \n    /**\n     * @dev Create a token packet with VRF randomness\n     */\n    function createTokenPacket(\n        address _tokenAddress,\n        uint256[] memory _rewardAmounts,\n        bool _useVRF\n    ) external returns (uint256) {\n        require(_rewardAmounts.length > 0 && _rewardAmounts.length <= 10, \"Invalid reward count\");\n        \n        uint256 totalValue = 0;\n        for (uint i = 0; i < _rewardAmounts.length; i++) {\n            totalValue += _rewardAmounts[i];\n        }\n        \n        IERC20 token = IERC20(_tokenAddress);\n        require(token.transferFrom(msg.sender, address(this), totalValue), \"Token transfer failed\");\n        \n        RewardType[] memory rewardTypes = new RewardType[](_rewardAmounts.length);\n        address[] memory tokenAddresses = new address[](_rewardAmounts.length);\n        \n        for (uint i = 0; i < _rewardAmounts.length; i++) {\n            rewardTypes[i] = RewardType.Token;\n            tokenAddresses[i] = _tokenAddress;\n        }\n        \n        uint256 packetId = _createPacket(\n            totalValue,\n            rewardTypes,\n            _rewardAmounts,\n            tokenAddresses,\n            new uint256[](_rewardAmounts.length),\n            _useVRF ? RandomnessSource.VRF : RandomnessSource.BlockHash\n        );\n        \n        return packetId;\n    }\n    \n    /**\n     * @dev Create a mixed packet with commit-reveal randomness\n     */\n    function createMixedPacket(\n        RewardType[] memory _rewardTypes,\n        uint256[] memory _rewardAmounts,\n        address[] memory _tokenAddresses,\n        uint256[] memory _nftIds\n    ) external payable returns (uint256) {\n        require(_rewardTypes.length > 0 && _rewardTypes.length <= 10, \"Invalid reward count\");\n        require(_rewardTypes.length == _rewardAmounts.length, \"Mismatched arrays\");\n        \n        uint256 ethValue = 0;\n        for (uint i = 0; i < _rewardTypes.length; i++) {\n            if (_rewardTypes[i] == RewardType.ETH) {\n                ethValue += _rewardAmounts[i];\n            } else if (_rewardTypes[i] == RewardType.Token) {\n                require(_tokenAddresses[i] != address(0), \"Invalid token address\");\n                IERC20(_tokenAddresses[i]).transferFrom(msg.sender, address(this), _rewardAmounts[i]);\n            }\n        }\n        \n        require(msg.value >= ethValue, \"Insufficient ETH sent\");\n        \n        uint256 packetId = _createPacket(\n            msg.value,\n            _rewardTypes,\n            _rewardAmounts,\n            _tokenAddresses,\n            _nftIds,\n            RandomnessSource.CommitReveal\n        );\n        \n        return packetId;\n    }\n    \n    /**\n     * @dev Internal function to create a packet\n     */\n    function _createPacket(\n        uint256 _totalValue,\n        RewardType[] memory _rewardTypes,\n        uint256[] memory _rewardAmounts,\n        address[] memory _tokenAddresses,\n        uint256[] memory _nftIds,\n        RandomnessSource _randomnessSource\n    ) internal returns (uint256) {\n        uint256 packetId = nextPacketId++;\n        \n        Packet storage packet = packets[packetId];\n        packet.creator = msg.sender;\n        packet.totalValue = _totalValue;\n        packet.createdAt = block.timestamp;\n        packet.expiresAt = block.timestamp + defaultExpiryTime;\n        packet.status = PacketStatus.Active;\n        packet.rewardTypes = _rewardTypes;\n        packet.rewardAmounts = _rewardAmounts;\n        packet.tokenAddresses = _tokenAddresses;\n        packet.nftIds = _nftIds;\n        packet.randomnessSource = _randomnessSource;\n        packet.requiresVRF = (_randomnessSource == RandomnessSource.VRF);\n        \n        userPackets[msg.sender].push(packetId);\n        \n        emit PacketCreated(packetId, msg.sender, _totalValue);\n        \n        return packetId;\n    }\n    \n    /**\n     * @dev Open a packet using block hash randomness\n     */\n    function openPacket(uint256 _packetId) external {\n        Packet storage packet = packets[_packetId];\n        require(packet.status == PacketStatus.Active, \"Packet not active\");\n        require(block.timestamp <= packet.expiresAt, \"Packet expired\");\n        require(!packet.requiresVRF, \"Use VRF opening method\");\n        require(packet.randomnessSource != RandomnessSource.CommitReveal, \"Use commit-reveal method\");\n        \n        uint256 randomValue = _generateBlockHashRandom(_packetId);\n        _distributeReward(_packetId, randomValue, msg.sender);\n    }\n    \n    /**\n     * @dev Open packet with VRF randomness\n     */\n    function openPacketWithVRF(uint256 _packetId) external {\n        Packet storage packet = packets[_packetId];\n        require(packet.status == PacketStatus.Active, \"Packet not active\");\n        require(block.timestamp <= packet.expiresAt, \"Packet expired\");\n        require(packet.requiresVRF, \"Use regular opening method\");\n        require(packet.vrfRequestId == 0, \"VRF already requested\");\n        \n        uint256 requestId = vrfCoordinator.requestRandomWords(\n            keyHash,\n            subscriptionId,\n            requestConfirmations,\n            callbackGasLimit,\n            1\n        );\n        \n        packet.vrfRequestId = requestId;\n        vrfRequestToPacket[requestId] = _packetId;\n        \n        emit RandomnessRequested(requestId, _packetId);\n    }\n    \n    /**\n     * @dev Chainlink VRF callback\n     */\n    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) external {\n        require(msg.sender == address(vrfCoordinator), \"Only VRF coordinator\");\n        \n        uint256 packetId = vrfRequestToPacket[_requestId];\n        require(packetId != 0, \"Invalid request ID\");\n        \n        uint256 randomValue = _randomWords[0];\n        emit RandomnessFulfilled(_requestId, randomValue);\n        \n        Packet storage packet = packets[packetId];\n        // Find who initiated the VRF request (simplified - in production, store this)\n        address opener = packet.creator; // This should be stored when VRF is requested\n        \n        _distributeReward(packetId, randomValue, opener);\n    }\n    \n    /**\n     * @dev Commit phase for commit-reveal randomness\n     */\n    function commitForPacket(uint256 _packetId, bytes32 _commitment) external {\n        Packet storage packet = packets[_packetId];\n        require(packet.status == PacketStatus.Active, \"Packet not active\");\n        require(packet.randomnessSource == RandomnessSource.CommitReveal, \"Not commit-reveal packet\");\n        \n        commitRevealData[_packetId] = CommitRevealData({\n            commitment: _commitment,\n            revealDeadline: block.timestamp + commitRevealWindow,\n            revealed: false,\n            nonce: 0\n        });\n    }\n    \n    /**\n     * @dev Reveal phase for commit-reveal randomness\n     */\n    function revealAndOpen(uint256 _packetId, uint256 _nonce, uint256 _value) external {\n        Packet storage packet = packets[_packetId];\n        CommitRevealData storage commitData = commitRevealData[_packetId];\n        \n        require(packet.status == PacketStatus.Active, \"Packet not active\");\n        require(block.timestamp <= commitData.revealDeadline, \"Reveal deadline passed\");\n        require(!commitData.revealed, \"Already revealed\");\n        require(\n            keccak256(abi.encodePacked(_value, _nonce)) == commitData.commitment,\n            \"Invalid reveal\"\n        );\n        \n        commitData.revealed = true;\n        commitData.nonce = _nonce;\n        \n        uint256 randomValue = uint256(keccak256(abi.encodePacked(_value, block.timestamp, block.difficulty)));\n        _distributeReward(_packetId, randomValue, msg.sender);\n    }\n    \n    /**\n     * @dev Generate pseudo-random number using block hash\n     */\n    function _generateBlockHashRandom(uint256 _packetId) internal view returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(\n            block.timestamp,\n            block.difficulty,\n            msg.sender,\n            _packetId,\n            blockhash(block.number - 1)\n        )));\n    }\n    \n    /**\n     * @dev Distribute reward based on random value\n     */\n    function _distributeReward(uint256 _packetId, uint256 _randomValue, address _opener) internal {\n        Packet storage packet = packets[_packetId];\n        packet.status = PacketStatus.Opened;\n        \n        if (packet.rewardTypes.length == 0) {\n            emit PacketOpened(_packetId, _opener, 0, RewardType.Empty);\n            return;\n        }\n        \n        uint256 rewardIndex = _randomValue % packet.rewardTypes.length;\n        RewardType rewardType = packet.rewardTypes[rewardIndex];\n        uint256 rewardAmount = packet.rewardAmounts[rewardIndex];\n        \n        if (rewardType == RewardType.ETH) {\n            payable(_opener).transfer(rewardAmount);\n        } else if (rewardType == RewardType.Token) {\n            IERC20(packet.tokenAddresses[rewardIndex]).transfer(_opener, rewardAmount);\n        }\n        // NFT transfers would be implemented here\n        \n        emit PacketOpened(_packetId, _opener, rewardAmount, rewardType);\n    }\n    \n    /**\n     * @dev Cancel an expired packet and refund creator\n     */\n    function cancelExpiredPacket(uint256 _packetId) external {\n        Packet storage packet = packets[_packetId];\n        require(packet.status == PacketStatus.Active, \"Packet not active\");\n        require(block.timestamp > packet.expiresAt, \"Packet not expired\");\n        require(msg.sender == packet.creator || msg.sender == owner, \"Not authorized\");\n        \n        packet.status = PacketStatus.Cancelled;\n        \n        // Refund ETH\n        if (packet.totalValue > 0) {\n            payable(packet.creator).transfer(packet.totalValue);\n        }\n        \n        // Refund tokens\n        for (uint i = 0; i < packet.rewardTypes.length; i++) {\n            if (packet.rewardTypes[i] == RewardType.Token) {\n                IERC20(packet.tokenAddresses[i]).transfer(packet.creator, packet.rewardAmounts[i]);\n            }\n        }\n    }\n    \n    /**\n     * @dev Get packet details\n     */\n    function getPacket(uint256 _packetId) external view returns (\n        address creator,\n        uint256 totalValue,\n        uint256 createdAt,\n        uint256 expiresAt,\n        PacketStatus status,\n        uint256 rewardCount\n    ) {\n        Packet storage packet = packets[_packetId];\n        return (\n            packet.creator,\n            packet.totalValue,\n            packet.createdAt,\n            packet.expiresAt,\n            packet.status,\n            packet.rewardTypes.length\n        );\n    }\n    \n    /**\n     * @dev Get user's packets\n     */\n    function getUserPackets(address _user) external view returns (uint256[] memory) {\n        return userPackets[_user];\n    }\n    \n    /**\n     * @dev Admin functions\n     */\n    function setAuthorizedCreator(address _creator, bool _authorized) external onlyOwner {\n        authorizedCreators[_creator] = _authorized;\n    }\n    \n    function setDefaultExpiryTime(uint256 _expiryTime) external onlyOwner {\n        defaultExpiryTime = _expiryTime;\n    }\n    \n    function setVRFParameters(\n        bytes32 _keyHash,\n        uint64 _subscriptionId,\n        uint16 _requestConfirmations,\n        uint32 _callbackGasLimit\n    ) external onlyOwner {\n        keyHash = _keyHash;\n        subscriptionId = _subscriptionId;\n        requestConfirmations = _requestConfirmations;\n        callbackGasLimit = _callbackGasLimit;\n    }\n    \n    /**\n     * @dev Emergency withdrawal function\n     */\n    function emergencyWithdraw() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n    \n    // Receive function to accept ETH\n    receive() external payable {}\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}