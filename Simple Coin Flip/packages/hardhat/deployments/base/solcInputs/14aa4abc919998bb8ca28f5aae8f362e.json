{
  "language": "Solidity",
  "sources": {
    "contracts/RockPaperScissors.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @title RockPaperScissors\r\n * @dev A provably fair Rock Paper Scissors game with betting and commitment-reveal scheme\r\n */\r\ncontract RockPaperScissors {\r\n    enum Choice { None, Rock, Paper, Scissors }\r\n    enum GameState { Open, Committed, Revealed, Finished }\r\n    \r\n    struct Game {\r\n        address player1;\r\n        address player2;\r\n        uint256 betAmount;\r\n        bytes32 player1Commitment;\r\n        bytes32 player2Commitment;\r\n        Choice player1Choice;\r\n        Choice player2Choice;\r\n        GameState state;\r\n        address winner;\r\n        uint256 createdAt;\r\n        uint256 deadline;\r\n        bool prizeClaimed;\r\n    }\r\n\r\n    // State variables\r\n    mapping(uint256 => Game) public games;\r\n    mapping(address => uint256[]) public playerGames;\r\n    mapping(address => uint256) public playerStats; // wins count\r\n    \r\n    uint256 public nextGameId;\r\n    uint256 public totalGames;\r\n    uint256 public totalVolume;\r\n    \r\n    // Platform fee (in basis points, 100 = 1%)\r\n    uint256 public platformFee = 200; // 2%\r\n    address public platformOwner;\r\n    uint256 public platformBalance;\r\n    \r\n    // Game settings\r\n    uint256 public constant REVEAL_TIMEOUT = 1 hours;\r\n    uint256 public constant MIN_BET = 0.001 ether;\r\n    uint256 public constant MAX_BET = 10 ether;\r\n\r\n    // Events\r\n    event GameCreated(\r\n        uint256 indexed gameId,\r\n        address indexed player1,\r\n        uint256 betAmount,\r\n        uint256 deadline\r\n    );\r\n    \r\n    event PlayerJoined(\r\n        uint256 indexed gameId,\r\n        address indexed player2\r\n    );\r\n    \r\n    event CommitmentMade(\r\n        uint256 indexed gameId,\r\n        address indexed player,\r\n        bytes32 commitment\r\n    );\r\n    \r\n    event ChoiceRevealed(\r\n        uint256 indexed gameId,\r\n        address indexed player,\r\n        Choice choice\r\n    );\r\n    \r\n    event GameFinished(\r\n        uint256 indexed gameId,\r\n        address indexed winner,\r\n        Choice player1Choice,\r\n        Choice player2Choice,\r\n        uint256 prize\r\n    );\r\n    \r\n    event PrizeClaimed(\r\n        uint256 indexed gameId,\r\n        address indexed winner,\r\n        uint256 amount\r\n    );\r\n\r\n    // Errors\r\n    error InvalidBetAmount();\r\n    error GameNotOpen();\r\n    error GameNotInCommitPhase();\r\n    error GameNotInRevealPhase();\r\n    error PlayerAlreadyInGame();\r\n    error NotGamePlayer();\r\n    error InvalidChoice();\r\n    error InvalidCommitment();\r\n    error RevealTimeoutNotReached();\r\n    error PrizeAlreadyClaimed();\r\n    error TransferFailed();\r\n    error GameExpired();\r\n    error UnauthorizedAccess();\r\n\r\n    // Modifiers\r\n    modifier onlyPlatformOwner() {\r\n        require(msg.sender == platformOwner, \"Only platform owner\");\r\n        _;\r\n    }\r\n\r\n    modifier gameExists(uint256 _gameId) {\r\n        require(_gameId < nextGameId, \"Game does not exist\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyGamePlayer(uint256 _gameId) {\r\n        Game memory game = games[_gameId];\r\n        require(msg.sender == game.player1 || msg.sender == game.player2, \"Not a game player\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        platformOwner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new Rock Paper Scissors game\r\n     * @param _commitment Player 1's commitment (hash of choice + nonce)\r\n     */\r\n    function createGame(bytes32 _commitment) external payable returns (uint256 gameId) {\r\n        if (msg.value < MIN_BET || msg.value > MAX_BET) revert InvalidBetAmount();\r\n        require(_commitment != bytes32(0), \"Invalid commitment\");\r\n\r\n        gameId = nextGameId++;\r\n        \r\n        games[gameId] = Game({\r\n            player1: msg.sender,\r\n            player2: address(0),\r\n            betAmount: msg.value,\r\n            player1Commitment: _commitment,\r\n            player2Commitment: bytes32(0),\r\n            player1Choice: Choice.None,\r\n            player2Choice: Choice.None,\r\n            state: GameState.Open,\r\n            winner: address(0),\r\n            createdAt: block.timestamp,\r\n            deadline: block.timestamp + REVEAL_TIMEOUT,\r\n            prizeClaimed: false\r\n        });\r\n\r\n        playerGames[msg.sender].push(gameId);\r\n        totalGames++;\r\n\r\n        emit GameCreated(gameId, msg.sender, msg.value, games[gameId].deadline);\r\n    }\r\n\r\n    /**\r\n     * @dev Join an existing game as player 2\r\n     * @param _gameId ID of the game to join\r\n     * @param _commitment Player 2's commitment\r\n     */\r\n    function joinGame(uint256 _gameId, bytes32 _commitment) \r\n        external \r\n        payable \r\n        gameExists(_gameId) \r\n    {\r\n        Game storage game = games[_gameId];\r\n        \r\n        if (game.state != GameState.Open) revert GameNotOpen();\r\n        require(msg.sender != game.player1, \"Cannot play against yourself\");\r\n        require(msg.value == game.betAmount, \"Must match bet amount\");\r\n        require(_commitment != bytes32(0), \"Invalid commitment\");\r\n\r\n        game.player2 = msg.sender;\r\n        game.player2Commitment = _commitment;\r\n        game.state = GameState.Committed;\r\n        game.deadline = block.timestamp + REVEAL_TIMEOUT;\r\n\r\n        playerGames[msg.sender].push(_gameId);\r\n        totalVolume += msg.value * 2;\r\n\r\n        emit PlayerJoined(_gameId, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Reveal player's choice\r\n     * @param _gameId ID of the game\r\n     * @param _choice Player's actual choice\r\n     * @param _nonce Nonce used in commitment\r\n     */\r\n    function revealChoice(uint256 _gameId, Choice _choice, uint256 _nonce) \r\n        external \r\n        gameExists(_gameId)\r\n        onlyGamePlayer(_gameId)\r\n    {\r\n        Game storage game = games[_gameId];\r\n        \r\n        if (game.state != GameState.Committed && game.state != GameState.Revealed) {\r\n            revert GameNotInRevealPhase();\r\n        }\r\n        \r\n        if (_choice == Choice.None || _choice > Choice.Scissors) revert InvalidChoice();\r\n\r\n        bytes32 commitment = keccak256(abi.encodePacked(_choice, _nonce, msg.sender));\r\n        \r\n        if (msg.sender == game.player1) {\r\n            if (commitment != game.player1Commitment) revert InvalidCommitment();\r\n            require(game.player1Choice == Choice.None, \"Already revealed\");\r\n            game.player1Choice = _choice;\r\n        } else {\r\n            if (commitment != game.player2Commitment) revert InvalidCommitment();\r\n            require(game.player2Choice == Choice.None, \"Already revealed\");\r\n            game.player2Choice = _choice;\r\n        }\r\n\r\n        emit ChoiceRevealed(_gameId, msg.sender, _choice);\r\n\r\n        // Check if both players have revealed\r\n        if (game.player1Choice != Choice.None && game.player2Choice != Choice.None) {\r\n            _finishGame(_gameId);\r\n        } else if (game.state == GameState.Committed) {\r\n            game.state = GameState.Revealed;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Claim prize for timeout (if opponent doesn't reveal in time)\r\n     * @param _gameId ID of the game\r\n     */\r\n    function claimTimeoutPrize(uint256 _gameId) \r\n        external \r\n        gameExists(_gameId)\r\n        onlyGamePlayer(_gameId)\r\n    {\r\n        Game storage game = games[_gameId];\r\n        \r\n        require(block.timestamp > game.deadline, \"Timeout not reached\");\r\n        require(game.state == GameState.Revealed, \"Game not in reveal phase\");\r\n        require(!game.prizeClaimed, \"Prize already claimed\");\r\n\r\n        // Determine winner based on who revealed\r\n        address winner;\r\n        if (game.player1Choice != Choice.None && game.player2Choice == Choice.None) {\r\n            winner = game.player1;\r\n        } else if (game.player2Choice != Choice.None && game.player1Choice == Choice.None) {\r\n            winner = game.player2;\r\n        } else {\r\n            revert(\"Invalid timeout claim\");\r\n        }\r\n\r\n        require(msg.sender == winner, \"Only winner can claim\");\r\n\r\n        game.winner = winner;\r\n        game.state = GameState.Finished;\r\n        game.prizeClaimed = true;\r\n\r\n        uint256 totalPot = game.betAmount * 2;\r\n        uint256 fee = (totalPot * platformFee) / 10000;\r\n        uint256 prize = totalPot - fee;\r\n\r\n        platformBalance += fee;\r\n        playerStats[winner]++;\r\n\r\n        (bool success, ) = payable(winner).call{value: prize}(\"\");\r\n        if (!success) revert TransferFailed();\r\n\r\n        emit PrizeClaimed(_gameId, winner, prize);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to finish game and determine winner\r\n     */\r\n    function _finishGame(uint256 _gameId) internal {\r\n        Game storage game = games[_gameId];\r\n        \r\n        address winner = _determineWinner(game.player1Choice, game.player2Choice);\r\n        \r\n        game.winner = winner;\r\n        game.state = GameState.Finished;\r\n        \r\n        uint256 totalPot = game.betAmount * 2;\r\n        uint256 fee = (totalPot * platformFee) / 10000;\r\n        uint256 prize = totalPot - fee;\r\n        \r\n        platformBalance += fee;\r\n\r\n        if (winner != address(0)) {\r\n            playerStats[winner]++;\r\n            (bool success, ) = payable(winner).call{value: prize}(\"\");\r\n            if (!success) revert TransferFailed();\r\n        } else {\r\n            // Tie - refund both players minus platform fee\r\n            uint256 refundAmount = (prize / 2);\r\n            \r\n            (bool success1, ) = payable(game.player1).call{value: refundAmount}(\"\");\r\n            (bool success2, ) = payable(game.player2).call{value: refundAmount}(\"\");\r\n            \r\n            if (!success1 || !success2) revert TransferFailed();\r\n        }\r\n        \r\n        game.prizeClaimed = true;\r\n\r\n        emit GameFinished(\r\n            _gameId, \r\n            winner, \r\n            game.player1Choice, \r\n            game.player2Choice, \r\n            prize\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Determine winner based on choices\r\n     * @param _choice1 Player 1's choice\r\n     * @param _choice2 Player 2's choice\r\n     * @return winner Address of winner, or address(0) for tie\r\n     */\r\n    function _determineWinner(Choice _choice1, Choice _choice2) \r\n        internal \r\n        view\r\n        returns (address winner) \r\n    {\r\n        if (_choice1 == _choice2) {\r\n            return address(0); // Tie\r\n        }\r\n        \r\n        Game storage game = games[0]; // Just to get player addresses\r\n        \r\n        if ((_choice1 == Choice.Rock && _choice2 == Choice.Scissors) ||\r\n            (_choice1 == Choice.Paper && _choice2 == Choice.Rock) ||\r\n            (_choice1 == Choice.Scissors && _choice2 == Choice.Paper)) {\r\n            return game.player1;\r\n        } else {\r\n            return game.player2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get game details\r\n     */\r\n    function getGame(uint256 _gameId) \r\n        external \r\n        view \r\n        gameExists(_gameId)\r\n        returns (\r\n            address player1,\r\n            address player2,\r\n            uint256 betAmount,\r\n            GameState state,\r\n            Choice player1Choice,\r\n            Choice player2Choice,\r\n            address winner,\r\n            uint256 deadline,\r\n            bool prizeClaimed\r\n        ) \r\n    {\r\n        Game memory game = games[_gameId];\r\n        return (\r\n            game.player1,\r\n            game.player2,\r\n            game.betAmount,\r\n            game.state,\r\n            game.player1Choice,\r\n            game.player2Choice,\r\n            game.winner,\r\n            game.deadline,\r\n            game.prizeClaimed\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Get player's game history\r\n     */\r\n    function getPlayerGames(address _player) \r\n        external \r\n        view \r\n        returns (uint256[] memory) \r\n    {\r\n        return playerGames[_player];\r\n    }\r\n\r\n    /**\r\n     * @dev Get open games for joining\r\n     */\r\n    function getOpenGames(uint256 _start, uint256 _limit) \r\n        external \r\n        view \r\n        returns (uint256[] memory openGames) \r\n    {\r\n        uint256[] memory temp = new uint256[](nextGameId);\r\n        uint256 count = 0;\r\n        \r\n        for (uint256 i = _start; i < nextGameId && count < _limit; i++) {\r\n            if (games[i].state == GameState.Open) {\r\n                temp[count] = i;\r\n                count++;\r\n            }\r\n        }\r\n        \r\n        openGames = new uint256[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            openGames[i] = temp[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Generate commitment hash for frontend\r\n     * @param _choice Player's choice\r\n     * @param _nonce Random nonce\r\n     * @param _player Player's address\r\n     */\r\n    function generateCommitment(Choice _choice, uint256 _nonce, address _player) \r\n        external \r\n        pure \r\n        returns (bytes32) \r\n    {\r\n        return keccak256(abi.encodePacked(_choice, _nonce, _player));\r\n    }\r\n\r\n    /**\r\n     * @dev Update platform fee (only owner)\r\n     */\r\n    function updatePlatformFee(uint256 _newFee) external onlyPlatformOwner {\r\n        require(_newFee <= 1000, \"Fee too high\"); // Max 10%\r\n        platformFee = _newFee;\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw platform fees\r\n     */\r\n    function withdrawPlatformFees() external onlyPlatformOwner {\r\n        uint256 amount = platformBalance;\r\n        platformBalance = 0;\r\n        \r\n        (bool success, ) = payable(platformOwner).call{value: amount}(\"\");\r\n        if (!success) revert TransferFailed();\r\n    }\r\n\r\n    /**\r\n     * @dev Get platform statistics\r\n     */\r\n    function getPlatformStats() external view returns (\r\n        uint256 _totalGames,\r\n        uint256 _totalVolume,\r\n        uint256 _platformFee,\r\n        uint256 _platformBalance\r\n    ) {\r\n        return (totalGames, totalVolume, platformFee, platformBalance);\r\n    }\r\n\r\n    /**\r\n     * @dev Get player statistics\r\n     */\r\n    function getPlayerStats(address _player) external view returns (uint256 wins) {\r\n        return playerStats[_player];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer ownership\r\n     */\r\n    function transferOwnership(address _newOwner) external onlyPlatformOwner {\r\n        require(_newOwner != address(0), \"Invalid address\");\r\n        platformOwner = _newOwner;\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}