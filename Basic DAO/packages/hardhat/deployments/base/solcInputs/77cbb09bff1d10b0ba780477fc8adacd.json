{
  "language": "Solidity",
  "sources": {
    "contracts/SimpleDAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @title SimpleDAO\r\n * @dev A basic DAO contract with proposal creation, voting, and execution capabilities\r\n */\r\ncontract SimpleDAO {\r\n    struct Proposal {\r\n        uint256 id;\r\n        address proposer;\r\n        string description;\r\n        uint256 amount; // Amount of ETH to transfer (if applicable)\r\n        address payable recipient; // Recipient of funds (if applicable)\r\n        uint256 votesFor;\r\n        uint256 votesAgainst;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        bool executed;\r\n        bool exists;\r\n        mapping(address => bool) hasVoted;\r\n        mapping(address => bool) voteChoice; // true = for, false = against\r\n    }\r\n\r\n    struct Member {\r\n        bool isMember;\r\n        uint256 joinedAt;\r\n        uint256 votingPower; // Number of votes they can cast\r\n    }\r\n\r\n    mapping(uint256 => Proposal) public proposals;\r\n    mapping(address => Member) public members;\r\n    \r\n    uint256 public nextProposalId = 1;\r\n    uint256 public memberCount;\r\n    uint256 public constant VOTING_PERIOD = 7 days;\r\n    uint256 public constant MIN_VOTING_POWER = 1;\r\n    uint256 public quorum = 51; // 51% quorum required\r\n    \r\n    address public admin;\r\n    \r\n    event ProposalCreated(\r\n        uint256 indexed proposalId,\r\n        address indexed proposer,\r\n        string description\r\n    );\r\n    \r\n    event VoteCast(\r\n        uint256 indexed proposalId,\r\n        address indexed voter,\r\n        bool support,\r\n        uint256 votingPower\r\n    );\r\n    \r\n    event ProposalExecuted(uint256 indexed proposalId, bool success);\r\n    \r\n    event MemberAdded(address indexed member, uint256 votingPower);\r\n    event MemberRemoved(address indexed member);\r\n    \r\n    error NotMember();\r\n    error ProposalNotFound();\r\n    error VotingEnded();\r\n    error VotingNotEnded();\r\n    error AlreadyVoted();\r\n    error AlreadyExecuted();\r\n    error QuorumNotMet();\r\n    error ProposalFailed();\r\n    error OnlyAdmin();\r\n    error AlreadyMember();\r\n    error TransferFailed();\r\n\r\n    modifier onlyMember() {\r\n        if (!members[msg.sender].isMember) revert NotMember();\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        if (msg.sender != admin) revert OnlyAdmin();\r\n        _;\r\n    }\r\n\r\n    modifier proposalExists(uint256 _proposalId) {\r\n        if (!proposals[_proposalId].exists) revert ProposalNotFound();\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        admin = msg.sender;\r\n        // Add admin as first member\r\n        members[msg.sender] = Member({\r\n            isMember: true,\r\n            joinedAt: block.timestamp,\r\n            votingPower: 1\r\n        });\r\n        memberCount = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a new member to the DAO (only admin can add members initially)\r\n     */\r\n    function addMember(address _member, uint256 _votingPower) external onlyAdmin {\r\n        if (members[_member].isMember) revert AlreadyMember();\r\n        require(_votingPower >= MIN_VOTING_POWER, \"Voting power too low\");\r\n\r\n        members[_member] = Member({\r\n            isMember: true,\r\n            joinedAt: block.timestamp,\r\n            votingPower: _votingPower\r\n        });\r\n        \r\n        memberCount++;\r\n        emit MemberAdded(_member, _votingPower);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a member from the DAO\r\n     */\r\n    function removeMember(address _member) external onlyAdmin {\r\n        if (!members[_member].isMember) revert NotMember();\r\n        \r\n        delete members[_member];\r\n        memberCount--;\r\n        emit MemberRemoved(_member);\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new proposal\r\n     */\r\n    function createProposal(\r\n        string memory _description,\r\n        uint256 _amount,\r\n        address payable _recipient\r\n    ) external onlyMember returns (uint256) {\r\n        uint256 proposalId = nextProposalId++;\r\n        \r\n        Proposal storage newProposal = proposals[proposalId];\r\n        newProposal.id = proposalId;\r\n        newProposal.proposer = msg.sender;\r\n        newProposal.description = _description;\r\n        newProposal.amount = _amount;\r\n        newProposal.recipient = _recipient;\r\n        newProposal.startTime = block.timestamp;\r\n        newProposal.endTime = block.timestamp + VOTING_PERIOD;\r\n        newProposal.exists = true;\r\n\r\n        emit ProposalCreated(proposalId, msg.sender, _description);\r\n        return proposalId;\r\n    }\r\n\r\n    /**\r\n     * @dev Vote on a proposal\r\n     */\r\n    function vote(uint256 _proposalId, bool _support) \r\n        external \r\n        onlyMember \r\n        proposalExists(_proposalId) \r\n    {\r\n        Proposal storage proposal = proposals[_proposalId];\r\n        \r\n        if (block.timestamp > proposal.endTime) revert VotingEnded();\r\n        if (proposal.hasVoted[msg.sender]) revert AlreadyVoted();\r\n\r\n        proposal.hasVoted[msg.sender] = true;\r\n        proposal.voteChoice[msg.sender] = _support;\r\n        \r\n        uint256 votingPower = members[msg.sender].votingPower;\r\n        \r\n        if (_support) {\r\n            proposal.votesFor += votingPower;\r\n        } else {\r\n            proposal.votesAgainst += votingPower;\r\n        }\r\n\r\n        emit VoteCast(_proposalId, msg.sender, _support, votingPower);\r\n    }\r\n\r\n    /**\r\n     * @dev Execute a proposal after voting period ends\r\n     */\r\n    function executeProposal(uint256 _proposalId) \r\n        external \r\n        proposalExists(_proposalId) \r\n    {\r\n        Proposal storage proposal = proposals[_proposalId];\r\n        \r\n        if (block.timestamp <= proposal.endTime) revert VotingNotEnded();\r\n        if (proposal.executed) revert AlreadyExecuted();\r\n\r\n        // Calculate total votes and check quorum\r\n        uint256 totalVotes = proposal.votesFor + proposal.votesAgainst;\r\n        uint256 totalVotingPower = getTotalVotingPower();\r\n        \r\n        if (totalVotes * 100 < totalVotingPower * quorum) revert QuorumNotMet();\r\n        if (proposal.votesFor <= proposal.votesAgainst) revert ProposalFailed();\r\n\r\n        proposal.executed = true;\r\n\r\n        bool success = true;\r\n        // Execute the proposal (transfer funds if specified)\r\n        if (proposal.amount > 0 && proposal.recipient != address(0)) {\r\n            if (address(this).balance >= proposal.amount) {\r\n                (bool sent, ) = proposal.recipient.call{value: proposal.amount}(\"\");\r\n                if (!sent) success = false;\r\n            } else {\r\n                success = false;\r\n            }\r\n        }\r\n\r\n        emit ProposalExecuted(_proposalId, success);\r\n    }\r\n\r\n    /**\r\n     * @dev Get proposal details\r\n     */\r\n    function getProposal(uint256 _proposalId) external view returns (\r\n        uint256 id,\r\n        address proposer,\r\n        string memory description,\r\n        uint256 amount,\r\n        address recipient,\r\n        uint256 votesFor,\r\n        uint256 votesAgainst,\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        bool executed,\r\n        bool isActive\r\n    ) {\r\n        Proposal storage proposal = proposals[_proposalId];\r\n        return (\r\n            proposal.id,\r\n            proposal.proposer,\r\n            proposal.description,\r\n            proposal.amount,\r\n            proposal.recipient,\r\n            proposal.votesFor,\r\n            proposal.votesAgainst,\r\n            proposal.startTime,\r\n            proposal.endTime,\r\n            proposal.executed,\r\n            block.timestamp <= proposal.endTime && !proposal.executed\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an address has voted on a proposal\r\n     */\r\n    function hasVoted(uint256 _proposalId, address _voter) \r\n        external \r\n        view \r\n        returns (bool voted, bool choice) \r\n    {\r\n        return (\r\n            proposals[_proposalId].hasVoted[_voter],\r\n            proposals[_proposalId].voteChoice[_voter]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Get total voting power of all members\r\n     */\r\n    function getTotalVotingPower() public view returns (uint256) {\r\n        // In a real implementation, you'd want to track this more efficiently\r\n        // For simplicity, this assumes each member has equal voting power\r\n        // You could extend this to sum up all members' voting power\r\n        uint256 total = 0;\r\n        // Note: This is a simplified version. In practice, you'd need to iterate\r\n        // through all members or maintain a running total\r\n        return memberCount; // Simplified - assumes each member has 1 vote\r\n    }\r\n\r\n    /**\r\n     * @dev Set quorum percentage (only admin)\r\n     */\r\n    function setQuorum(uint256 _quorum) external onlyAdmin {\r\n        require(_quorum > 0 && _quorum <= 100, \"Invalid quorum percentage\");\r\n        quorum = _quorum;\r\n    }\r\n\r\n    /**\r\n     * @dev Allow the DAO to receive ETH\r\n     */\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @dev Get contract balance\r\n     */\r\n    function getBalance() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    /**\r\n     * @dev Emergency withdraw (only admin) - for initial setup phase\r\n     */\r\n    function emergencyWithdraw() external onlyAdmin {\r\n        (bool success, ) = payable(admin).call{value: address(this).balance}(\"\");\r\n        if (!success) revert TransferFailed();\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}